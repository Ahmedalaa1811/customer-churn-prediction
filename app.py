import streamlit as st
import pandas as pd
import numpy as np
import joblib
import io
import matplotlib.pyplot as plt
import seaborn as sns
import shap
from datetime import datetime
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader

# =========================
# Config
# =========================
st.set_page_config(page_title="Customer Churn Prediction", layout="wide")
st.title("📊 Customer Churn Prediction App — Pro Edition")

# =========================
# Load Model
# =========================
@st.cache_resource(show_spinner=False)
def load_model_and_threshold():
    model = joblib.load("models/churn_model.pkl")
    with open("models/churn_threshold.txt", "r") as f:
        threshold = float(f.read().strip())
    return model, threshold

model, default_threshold = load_model_and_threshold()

# =========================
# Narrative Generator
# =========================
def generate_narrative(results: pd.DataFrame) -> str:
    churn_rate = results["Churn_Prediction"].mean() * 100
    churn_geo = results.groupby("Geography")["Churn_Prediction"].mean()
    churn_gender = results.groupby("Gender")["Churn_Prediction"].mean()
    churn_products = results.groupby("NumOfProducts")["Churn_Prediction"].mean()
    churn_tenure = results.groupby("Tenure")["Churn_Prediction"].mean()

    narrative = f"Overall churn rate is {churn_rate:.1f}%, "
    if len(churn_geo):
        narrative += f"Highest churn is in {churn_geo.idxmax()}, "
    if len(churn_gender):
        narrative += f"{churn_gender.idxmax()} customers churn more, "
    if len(churn_products):
        narrative += f"Customers with {int(churn_products.idxmax())} products churn the most, "
    if len(churn_tenure):
        narrative += f"Churn peaks at {int(churn_tenure.idxmax())} years of tenure."
    return narrative

# =========================
# Plot Helper
# =========================
def save_and_show(fig, width=250, height=200):
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight", dpi=150)
    buf.seek(0)
    st.pyplot(fig)
    return buf

# =========================
# PDF Export
# =========================
def generate_pdf(churn_rate, churn_count, stay_count,
                 geo_buf, age_buf, gender_buf, products_buf, tenure_buf,
                 top_customers, kpi_text, threshold_buf):
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)

    # ---------------- Cover / Summary ----------------
    c.setFont("Helvetica-Bold", 16)
    c.drawString(150, 750, "Customer Churn Prediction Report")

    c.setFont("Helvetica", 10)
    c.drawString(50, 730, f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}")

    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, 700, "Executive KPIs")
    c.setFont("Helvetica", 12)
    c.drawString(50, 680, kpi_text["customers"])
    c.drawString(50, 660, kpi_text["revenue"])

    c.setFont("Helvetica-Bold", 12)
    c.drawString(50, 630, "Churn Overview")
    c.setFont("Helvetica", 11)
    c.drawString(50, 610, f"Churn Rate: {churn_rate:.1f}%")
    c.drawString(50, 595, f"Churners: {churn_count}")
    c.drawString(50, 580, f"Non-Churners: {stay_count}")

    c.showPage()

    # ---------------- Threshold Optimization ----------------
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, 750, "Threshold Optimization Analysis")
    c.setFont("Helvetica", 10)
    c.drawString(50, 730, "The curve below shows expected cost across thresholds. "
                          "The optimal threshold minimizes total business cost.")

    c.drawImage(ImageReader(threshold_buf), 50, 380, width=500, height=300)
    c.showPage()

    # ---------------- Churn Insights ----------------
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, 750, "Churn Insights by Feature")

    c.drawImage(ImageReader(geo_buf), 50, 500, width=250, height=200)
    c.drawImage(ImageReader(age_buf), 320, 500, width=250, height=200)

    c.drawImage(ImageReader(gender_buf), 50, 260, width=250, height=200)
    c.drawImage(ImageReader(products_buf), 320, 260, width=250, height=200)

    c.showPage()

    # ---------------- Tenure + Top Customers ----------------
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, 750, "Tenure & High-Risk Customers")

    c.drawImage(ImageReader(tenure_buf), 50, 450, width=300, height=200)

    c.setFont("Helvetica-Bold", 12)
    c.drawString(50, 420, "Top 10 High-Risk Customers:")
    c.setFont("Helvetica", 10)
    y = 400
    for idx, row in top_customers.iterrows():
        c.drawString(50, y, f"Customer {idx} — Prob: {row['Churn_Probability']:.2f}")
        y -= 15
        if y < 50:
            c.showPage()
            y = 750

    # ---------------- Footer ----------------
    c.setFont("Helvetica-Oblique", 8)
    c.drawString(50, 30, "Generated by Churn Prediction App — Pro Edition")

    c.save()
    buffer.seek(0)
    return buffer

# =========================
# SHAP with preprocessing
# =========================
def compute_shap_background(df: pd.DataFrame, max_samples: int = 200):
    if df is None or df.empty:
        return None, None, None

    bg = df.sample(min(len(df), max_samples), random_state=42)

    if "preprocessor" in model.named_steps:
        pre = model.named_steps["preprocessor"]
        bg_trans = pre.transform(bg)
        feature_names = pre.get_feature_names_out()
        clf = model.named_steps["classifier"]
        explainer = shap.Explainer(clf.predict_proba, bg_trans, feature_names=feature_names)
    else:
        bg_trans = bg
        feature_names = df.columns
        explainer = shap.Explainer(model.predict_proba, bg_trans, feature_names=feature_names)

    return explainer, bg, feature_names

# =========================
# Tabs
# =========================
tabs = st.tabs([
    "🔮 Single Prediction",
    "📂 Batch Prediction & Insights",
    "🔎 Explainability & What-If",
    "⚙️ Threshold & Costs",
    "📈 Executive KPIs",
    "ℹ️ About"
])

# ---------------- Tab 1: Single Prediction ----------------
with tabs[0]:
    st.header("👤 Single Customer Prediction")
    with st.form("single_customer_form"):
        credit_score = st.number_input("Credit Score", 0, 1000, 650)
        geography = st.selectbox("Geography", ["France", "Spain", "Germany"])
        gender = st.selectbox("Gender", ["Male", "Female"])
        age = st.number_input("Age", 18, 100, 35)
        tenure = st.number_input("Tenure", 0, 50, 5)
        balance = st.number_input("Balance", 0.0, 500000.0)
        products = st.number_input("Products", 1, 10, 1)
        has_card = st.selectbox("Has Credit Card?", [0, 1])
        active = st.selectbox("Is Active Member?", [0, 1])
        salary = st.number_input("Estimated Salary", 0.0, 200000.0)

        thr = st.slider("Decision Threshold", 0.05, 0.95, float(default_threshold), 0.01)
        submitted = st.form_submit_button("Predict")

    if submitted:
        single_df = pd.DataFrame([{
            "CreditScore": credit_score, "Geography": geography, "Gender": gender,
            "Age": age, "Tenure": tenure, "Balance": balance,
            "NumOfProducts": products, "HasCrCard": has_card,
            "IsActiveMember": active, "EstimatedSalary": salary
        }])
        prob = model.predict_proba(single_df)[:, 1][0]
        pred = int(prob >= thr)
        st.write(f"### Prediction: {'❌ Will Churn' if pred else '✅ Will Stay'}")
        st.metric("Churn Probability", f"{prob:.2%}")

# ---------------- Tab 2: Batch ----------------
with tabs[1]:
    st.header("📂 Batch Predictions & Insights")
    uploaded = st.file_uploader("Upload CSV", type=["csv"])
    if uploaded:
        data = pd.read_csv(uploaded)
        probs = model.predict_proba(data)[:, 1]
        preds = (probs >= default_threshold).astype(int)
        results = data.copy()
        results["Churn_Probability"] = probs
        results["Churn_Prediction"] = preds

        st.dataframe(results.head())
        st.download_button("📥 Download CSV", results.to_csv(index=False).encode(),
                           "churn_predictions.csv", "text/csv")

        churn_rate = results["Churn_Prediction"].mean() * 100
        churn_count = results["Churn_Prediction"].sum()
        stay_count = len(results) - churn_count
        col1, col2, col3 = st.columns(3)
        col1.metric("Churn Rate", f"{churn_rate:.1f}%")
        col2.metric("Churners", churn_count)
        col3.metric("Non-Churners", stay_count)

        # Row 1: Geography & Age
        col1, col2 = st.columns(2)
        with col1:
            fig_geo, ax = plt.subplots(figsize=(3,2))
            sns.countplot(data=results, x="Geography", hue="Churn_Prediction", ax=ax)
            geo_buf = save_and_show(fig_geo)
        with col2:
            fig_age, ax2 = plt.subplots(figsize=(3,2))
            sns.kdeplot(data=results, x="Age", hue="Churn_Prediction", fill=True, ax=ax2)
            age_buf = save_and_show(fig_age)

        # Row 2: Gender & Products
        col3, col4 = st.columns(2)
        with col3:
            fig_gender, ax3 = plt.subplots(figsize=(3,2))
            sns.countplot(data=results, x="Gender", hue="Churn_Prediction", ax=ax3)
            gender_buf = save_and_show(fig_gender)
        with col4:
            fig_products, ax4 = plt.subplots(figsize=(3,2))
            sns.countplot(data=results, x="NumOfProducts", hue="Churn_Prediction", ax=ax4)
            products_buf = save_and_show(fig_products)

        # Row 3: Tenure
        col_left, col_center, col_right = st.columns([1,3,1])
        with col_center:
            fig_tenure, ax5 = plt.subplots(figsize=(5,3))
            sns.histplot(data=results, x="Tenure", hue="Churn_Prediction", multiple="stack", ax=ax5)
            tenure_buf = save_and_show(fig_tenure)

        # Narrative
        narrative = generate_narrative(results)
        st.subheader("📖 Narrative")
        st.write(narrative)

        # Save results for later tabs
        st.session_state["results"] = results
        st.session_state["buffers"] = (geo_buf, age_buf, gender_buf, products_buf, tenure_buf)

# ---------------- Tab 3: Explainability ----------------
with tabs[2]:
    st.header("🔎 Explainability & What-If")
    results = st.session_state.get("results")
    if results is not None:
        idx = st.number_input("Select row index", 0, len(results)-1, 0)
        row = results.iloc[[idx]][[
            "CreditScore","Geography","Gender","Age","Tenure",
            "Balance","NumOfProducts","HasCrCard","IsActiveMember","EstimatedSalary"
        ]]

        explainer, bg, feature_names = compute_shap_background(results[[
            "CreditScore","Geography","Gender","Age","Tenure",
            "Balance","NumOfProducts","HasCrCard","IsActiveMember","EstimatedSalary"
        ]])

        friendly_map = {
            "CreditScore": "Credit Score",
            "Geography": "Country",
            "Gender": "Gender",
            "Age": "Age",
            "Tenure": "Tenure (Years)",
            "Balance": "Account Balance",
            "NumOfProducts": "Number of Products",
            "HasCrCard": "Has Credit Card",
            "IsActiveMember": "Active Member",
            "EstimatedSalary": "Estimated Salary",
            "cat__Gender_Female": "Gender = Female",
            "cat__Gender_Male": "Gender = Male",
            "cat__Geography_France": "Country = France",
            "cat__Geography_Spain": "Country = Spain",
            "cat__Geography_Germany": "Country = Germany",
        }
        feature_names = [friendly_map.get(f, f) for f in feature_names]

        if explainer:
            if "preprocessor" in model.named_steps:
                row_trans = model.named_steps["preprocessor"].transform(row)
            else:
                row_trans = row
            shap_values = explainer(row_trans)
            st.subheader("Local Explanation")
            try:
                shap.plots.waterfall(shap_values[0], show=False)
                st.pyplot(plt.gcf()); plt.clf()
            except Exception:
                vals = shap_values.values[0]
                if vals.ndim == 2 and vals.shape[1] == 2:
                    vals = vals[:, 1]
                st.bar_chart(pd.Series(vals, index=feature_names))
    else:
        st.info("Upload data first.")

# ---------------- Tab 4: Threshold ----------------
with tabs[3]:
    st.header("⚙️ Threshold Optimization")
    results = st.session_state.get("results")
    if results is not None:
        probs = results["Churn_Probability"].values
        cost_fp = st.number_input("Cost False Positive", 0.0, 50.0, 5.0)
        cost_fn = st.number_input("Cost False Negative", 0.0, 500.0, 100.0)
        grid = np.linspace(0.05, 0.95, 30)
        costs = []
        for th in grid:
            preds = (probs >= th).astype(int)
            exp_fn = np.sum((preds==0) * probs) * cost_fn
            exp_fp = np.sum((preds==1) * (1-probs)) * cost_fp
            costs.append(exp_fn+exp_fp)
        best_thr = grid[np.argmin(costs)]
        st.metric("Suggested Threshold", f"{best_thr:.2f}")
        col = st.columns([1,3,1])
        with col[1]:
            fig, ax = plt.subplots(figsize=(5,3))
            ax.plot(grid, costs, label="Expected Cost")
            ax.axvline(best_thr, ls="--", color="red", label=f"Best Threshold = {best_thr:.2f}")
            ax.set_xlabel("Threshold")
            ax.set_ylabel("Cost")
            ax.legend()
            threshold_buf = save_and_show(fig)

        # Save for PDF
        st.session_state["threshold_buf"] = threshold_buf
        st.session_state["best_thr"] = best_thr
    else:
        st.info("Upload data first.")

# ---------------- Tab 5: KPIs ----------------
with tabs[4]:
    st.header("📈 Executive KPIs")
    results = st.session_state.get("results")
    if results is not None:
        arpu = st.number_input("Avg Monthly Revenue ($)", 0.0, 500.0, 50.0)
        horizon = st.number_input("Horizon (months)", 1, 24, 6)
        highrisk = results[results["Churn_Probability"] >= default_threshold]
        at_risk_customers = len(highrisk)
        at_risk_revenue = at_risk_customers * arpu * horizon
        st.metric("At-Risk Customers", at_risk_customers)
        st.metric("At-Risk Revenue", f"${at_risk_revenue:,.0f}")

        # Save KPI text for PDF
        st.session_state["kpi_text"] = {
            "customers": f"At-Risk Customers: {at_risk_customers}",
            "revenue": f"At-Risk Revenue: ${at_risk_revenue:,.0f}"
        }

        # Add PDF download here
        if "buffers" in st.session_state and "threshold_buf" in st.session_state:
            geo_buf, age_buf, gender_buf, products_buf, tenure_buf = st.session_state["buffers"]
            threshold_buf = st.session_state["threshold_buf"]
            kpi_text = st.session_state.get("kpi_text", {"customers": "", "revenue": ""})
            top_customers = results.sort_values("Churn_Probability", ascending=False).head(10)
            churn_rate = results["Churn_Prediction"].mean() * 100
            churn_count = results["Churn_Prediction"].sum()
            stay_count = len(results) - churn_count

            pdf = generate_pdf(
                churn_rate, churn_count, stay_count,
                geo_buf, age_buf, gender_buf, products_buf, tenure_buf,
                top_customers, kpi_text, threshold_buf
            )
            st.download_button("📥 Download Full PDF Report", pdf, "churn_report.pdf", "application/pdf")
    else:
        st.info("Upload data first.")
# ---------------- Tab 6: About ----------------
with tabs[5]:
    st.header("ℹ️ About")
    st.write(f"""
    Enhanced **Customer Churn Prediction App — Pro Edition** with:

    - 🔮 SHAP Explainability (with **friendly feature names**)
    - 📂 Batch Predictions with **compact, side-by-side charts**
    - 📖 Narrative Insights (executive summaries auto-generated)
    - 📥 **PDF Exports** (with sharp, clear diagrams & top customers list)
    - ⚙️ Threshold Optimization with cost-based analysis
    - 📈 Executive KPIs (at-risk customers & revenue impact)

    Author: Ahmed ALAA-ELSHEIKH  
    [LinkedIn](https://www.linkedin.com/in/ahmed-alaa-elsheikh-98a4b5182/) | 
    [Email](mailto:ahmed.alaa181197@gmail.com)
    """)